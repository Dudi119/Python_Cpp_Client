// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_SWEETPY_SERIALIZE_H_
#define FLATBUFFERS_GENERATED_TYPES_SWEETPY_SERIALIZE_H_

#include "flatbuffers/flatbuffers.h"

namespace sweetPy {
namespace serialize {

struct String;

struct Short;

struct Int;

struct Double;

struct Bool;

struct TupleParam;

struct Tuple;

struct Function;

struct Object;

struct Objects;

enum class integral_types : uint8_t {
  NONE = 0,
  String = 1,
  Int = 2,
  Short = 3,
  Double = 4,
  Bool = 5,
  MIN = NONE,
  MAX = Bool
};

inline const integral_types (&EnumValuesintegral_types())[6] {
  static const integral_types values[] = {
    integral_types::NONE,
    integral_types::String,
    integral_types::Int,
    integral_types::Short,
    integral_types::Double,
    integral_types::Bool
  };
  return values;
}

inline const char * const *EnumNamesintegral_types() {
  static const char * const names[] = {
    "NONE",
    "String",
    "Int",
    "Short",
    "Double",
    "Bool",
    nullptr
  };
  return names;
}

inline const char *EnumNameintegral_types(integral_types e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesintegral_types()[index];
}

template<typename T> struct integral_typesTraits {
  static const integral_types enum_value = integral_types::NONE;
};

template<> struct integral_typesTraits<String> {
  static const integral_types enum_value = integral_types::String;
};

template<> struct integral_typesTraits<Int> {
  static const integral_types enum_value = integral_types::Int;
};

template<> struct integral_typesTraits<Short> {
  static const integral_types enum_value = integral_types::Short;
};

template<> struct integral_typesTraits<Double> {
  static const integral_types enum_value = integral_types::Double;
};

template<> struct integral_typesTraits<Bool> {
  static const integral_types enum_value = integral_types::Bool;
};

bool Verifyintegral_types(flatbuffers::Verifier &verifier, const void *obj, integral_types type);
bool Verifyintegral_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class all_types : uint8_t {
  NONE = 0,
  String = 1,
  Int = 2,
  Short = 3,
  Double = 4,
  Bool = 5,
  Tuple = 6,
  Function = 7,
  MIN = NONE,
  MAX = Function
};

inline const all_types (&EnumValuesall_types())[8] {
  static const all_types values[] = {
    all_types::NONE,
    all_types::String,
    all_types::Int,
    all_types::Short,
    all_types::Double,
    all_types::Bool,
    all_types::Tuple,
    all_types::Function
  };
  return values;
}

inline const char * const *EnumNamesall_types() {
  static const char * const names[] = {
    "NONE",
    "String",
    "Int",
    "Short",
    "Double",
    "Bool",
    "Tuple",
    "Function",
    nullptr
  };
  return names;
}

inline const char *EnumNameall_types(all_types e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesall_types()[index];
}

template<typename T> struct all_typesTraits {
  static const all_types enum_value = all_types::NONE;
};

template<> struct all_typesTraits<String> {
  static const all_types enum_value = all_types::String;
};

template<> struct all_typesTraits<Int> {
  static const all_types enum_value = all_types::Int;
};

template<> struct all_typesTraits<Short> {
  static const all_types enum_value = all_types::Short;
};

template<> struct all_typesTraits<Double> {
  static const all_types enum_value = all_types::Double;
};

template<> struct all_typesTraits<Bool> {
  static const all_types enum_value = all_types::Bool;
};

template<> struct all_typesTraits<Tuple> {
  static const all_types enum_value = all_types::Tuple;
};

template<> struct all_typesTraits<Function> {
  static const all_types enum_value = all_types::Function;
};

bool Verifyall_types(flatbuffers::Verifier &verifier, const void *obj, all_types type);
bool Verifyall_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringBuilder &operator=(const StringBuilder &);
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return sweetPy::serialize::CreateString(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct Short FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShortBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Short::VT_VALUE, value, 0);
  }
  explicit ShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortBuilder &operator=(const ShortBuilder &);
  flatbuffers::Offset<Short> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Short>(end);
    return o;
  }
};

inline flatbuffers::Offset<Short> CreateShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  ShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleBuilder &operator=(const DoubleBuilder &);
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolBuilder &operator=(const BoolBuilder &);
  flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TupleParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PARAM_TYPE = 4,
    VT_PARAM = 6
  };
  integral_types param_type() const {
    return static_cast<integral_types>(GetField<uint8_t>(VT_PARAM_TYPE, 0));
  }
  const void *param() const {
    return GetPointer<const void *>(VT_PARAM);
  }
  template<typename T> const T *param_as() const;
  const String *param_as_String() const {
    return param_type() == integral_types::String ? static_cast<const String *>(param()) : nullptr;
  }
  const Int *param_as_Int() const {
    return param_type() == integral_types::Int ? static_cast<const Int *>(param()) : nullptr;
  }
  const Short *param_as_Short() const {
    return param_type() == integral_types::Short ? static_cast<const Short *>(param()) : nullptr;
  }
  const Double *param_as_Double() const {
    return param_type() == integral_types::Double ? static_cast<const Double *>(param()) : nullptr;
  }
  const Bool *param_as_Bool() const {
    return param_type() == integral_types::Bool ? static_cast<const Bool *>(param()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARAM_TYPE) &&
           VerifyOffset(verifier, VT_PARAM) &&
           Verifyintegral_types(verifier, param(), param_type()) &&
           verifier.EndTable();
  }
};

template<> inline const String *TupleParam::param_as<String>() const {
  return param_as_String();
}

template<> inline const Int *TupleParam::param_as<Int>() const {
  return param_as_Int();
}

template<> inline const Short *TupleParam::param_as<Short>() const {
  return param_as_Short();
}

template<> inline const Double *TupleParam::param_as<Double>() const {
  return param_as_Double();
}

template<> inline const Bool *TupleParam::param_as<Bool>() const {
  return param_as_Bool();
}

struct TupleParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_param_type(integral_types param_type) {
    fbb_.AddElement<uint8_t>(TupleParam::VT_PARAM_TYPE, static_cast<uint8_t>(param_type), 0);
  }
  void add_param(flatbuffers::Offset<void> param) {
    fbb_.AddOffset(TupleParam::VT_PARAM, param);
  }
  explicit TupleParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleParamBuilder &operator=(const TupleParamBuilder &);
  flatbuffers::Offset<TupleParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TupleParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<TupleParam> CreateTupleParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    integral_types param_type = integral_types::NONE,
    flatbuffers::Offset<void> param = 0) {
  TupleParamBuilder builder_(_fbb);
  builder_.add_param(param);
  builder_.add_param_type(param_type);
  return builder_.Finish();
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PARAMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TupleParam>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TupleParam>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TupleParam>>> params) {
    fbb_.AddOffset(Tuple::VT_PARAMS, params);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleBuilder &operator=(const TupleBuilder &);
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TupleParam>>> params = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_params(params);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TupleParam>> *params = nullptr) {
  return sweetPy::serialize::CreateTuple(
      _fbb,
      params ? _fbb.CreateVector<flatbuffers::Offset<TupleParam>>(*params) : 0);
}

struct Function FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BYTE_CODE = 4
  };
  const flatbuffers::String *byte_code() const {
    return GetPointer<const flatbuffers::String *>(VT_BYTE_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTE_CODE) &&
           verifier.VerifyString(byte_code()) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_byte_code(flatbuffers::Offset<flatbuffers::String> byte_code) {
    fbb_.AddOffset(Function::VT_BYTE_CODE, byte_code);
  }
  explicit FunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionBuilder &operator=(const FunctionBuilder &);
  flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline flatbuffers::Offset<Function> CreateFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> byte_code = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_byte_code(byte_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Function> CreateFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *byte_code = nullptr) {
  return sweetPy::serialize::CreateFunction(
      _fbb,
      byte_code ? _fbb.CreateString(byte_code) : 0);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  all_types object_type() const {
    return static_cast<all_types>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const String *object_as_String() const {
    return object_type() == all_types::String ? static_cast<const String *>(object()) : nullptr;
  }
  const Int *object_as_Int() const {
    return object_type() == all_types::Int ? static_cast<const Int *>(object()) : nullptr;
  }
  const Short *object_as_Short() const {
    return object_type() == all_types::Short ? static_cast<const Short *>(object()) : nullptr;
  }
  const Double *object_as_Double() const {
    return object_type() == all_types::Double ? static_cast<const Double *>(object()) : nullptr;
  }
  const Bool *object_as_Bool() const {
    return object_type() == all_types::Bool ? static_cast<const Bool *>(object()) : nullptr;
  }
  const Tuple *object_as_Tuple() const {
    return object_type() == all_types::Tuple ? static_cast<const Tuple *>(object()) : nullptr;
  }
  const Function *object_as_Function() const {
    return object_type() == all_types::Function ? static_cast<const Function *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           Verifyall_types(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const String *Object::object_as<String>() const {
  return object_as_String();
}

template<> inline const Int *Object::object_as<Int>() const {
  return object_as_Int();
}

template<> inline const Short *Object::object_as<Short>() const {
  return object_as_Short();
}

template<> inline const Double *Object::object_as<Double>() const {
  return object_as_Double();
}

template<> inline const Bool *Object::object_as<Bool>() const {
  return object_as_Bool();
}

template<> inline const Tuple *Object::object_as<Tuple>() const {
  return object_as_Tuple();
}

template<> inline const Function *Object::object_as<Function>() const {
  return object_as_Function();
}

struct ObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(all_types object_type) {
    fbb_.AddElement<uint8_t>(Object::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Object::VT_OBJECT, object);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    all_types object_type = all_types::NONE,
    flatbuffers::Offset<void> object = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Objects FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Object>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct ObjectsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects) {
    fbb_.AddOffset(Objects::VT_OBJECTS, objects);
  }
  explicit ObjectsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectsBuilder &operator=(const ObjectsBuilder &);
  flatbuffers::Offset<Objects> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Objects>(end);
    return o;
  }
};

inline flatbuffers::Offset<Objects> CreateObjects(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects = 0) {
  ObjectsBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<Objects> CreateObjectsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Object>> *objects = nullptr) {
  return sweetPy::serialize::CreateObjects(
      _fbb,
      objects ? _fbb.CreateVector<flatbuffers::Offset<Object>>(*objects) : 0);
}

inline bool Verifyintegral_types(flatbuffers::Verifier &verifier, const void *obj, integral_types type) {
  switch (type) {
    case integral_types::NONE: {
      return true;
    }
    case integral_types::String: {
      auto ptr = reinterpret_cast<const String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types::Int: {
      auto ptr = reinterpret_cast<const Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types::Short: {
      auto ptr = reinterpret_cast<const Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types::Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types::Bool: {
      auto ptr = reinterpret_cast<const Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool Verifyintegral_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifyintegral_types(
        verifier,  values->Get(i), types->GetEnum<integral_types>(i))) {
      return false;
    }
  }
  return true;
}

inline bool Verifyall_types(flatbuffers::Verifier &verifier, const void *obj, all_types type) {
  switch (type) {
    case all_types::NONE: {
      return true;
    }
    case all_types::String: {
      auto ptr = reinterpret_cast<const String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types::Int: {
      auto ptr = reinterpret_cast<const Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types::Short: {
      auto ptr = reinterpret_cast<const Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types::Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types::Bool: {
      auto ptr = reinterpret_cast<const Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types::Tuple: {
      auto ptr = reinterpret_cast<const Tuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types::Function: {
      auto ptr = reinterpret_cast<const Function *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool Verifyall_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifyall_types(
        verifier,  values->Get(i), types->GetEnum<all_types>(i))) {
      return false;
    }
  }
  return true;
}

inline const sweetPy::serialize::Objects *GetObjects(const void *buf) {
  return flatbuffers::GetRoot<sweetPy::serialize::Objects>(buf);
}

inline const sweetPy::serialize::Objects *GetSizePrefixedObjects(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<sweetPy::serialize::Objects>(buf);
}

inline bool VerifyObjectsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sweetPy::serialize::Objects>(nullptr);
}

inline bool VerifySizePrefixedObjectsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sweetPy::serialize::Objects>(nullptr);
}

inline void FinishObjectsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sweetPy::serialize::Objects> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedObjectsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sweetPy::serialize::Objects> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace serialize
}  // namespace sweetPy

#endif  // FLATBUFFERS_GENERATED_TYPES_SWEETPY_SERIALIZE_H_
