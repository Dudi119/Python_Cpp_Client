// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_SWEETPY_SERIALIZE_H_
#define FLATBUFFERS_GENERATED_TYPES_SWEETPY_SERIALIZE_H_

#include "flatbuffers/flatbuffers.h"

namespace sweetPy {
namespace serialize {

struct String;

struct Short;

struct Int;

struct Double;

struct Bool;

struct ContainerParam;

struct Container;

struct Tuple;

struct List;

struct DictParam;

struct Dict;

struct Object;

struct Objects;

enum integral_types {
  integral_types_NONE = 0,
  integral_types_String = 1,
  integral_types_Int = 2,
  integral_types_Short = 3,
  integral_types_Double = 4,
  integral_types_Bool = 5,
  integral_types_MIN = integral_types_NONE,
  integral_types_MAX = integral_types_Bool
};

inline const integral_types (&EnumValuesintegral_types())[6] {
  static const integral_types values[] = {
    integral_types_NONE,
    integral_types_String,
    integral_types_Int,
    integral_types_Short,
    integral_types_Double,
    integral_types_Bool
  };
  return values;
}

inline const char * const *EnumNamesintegral_types() {
  static const char * const names[] = {
    "NONE",
    "String",
    "Int",
    "Short",
    "Double",
    "Bool",
    nullptr
  };
  return names;
}

inline const char *EnumNameintegral_types(integral_types e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesintegral_types()[index];
}

template<typename T> struct integral_typesTraits {
  static const integral_types enum_value = integral_types_NONE;
};

template<> struct integral_typesTraits<String> {
  static const integral_types enum_value = integral_types_String;
};

template<> struct integral_typesTraits<Int> {
  static const integral_types enum_value = integral_types_Int;
};

template<> struct integral_typesTraits<Short> {
  static const integral_types enum_value = integral_types_Short;
};

template<> struct integral_typesTraits<Double> {
  static const integral_types enum_value = integral_types_Double;
};

template<> struct integral_typesTraits<Bool> {
  static const integral_types enum_value = integral_types_Bool;
};

bool Verifyintegral_types(flatbuffers::Verifier &verifier, const void *obj, integral_types type);
bool Verifyintegral_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum all_types {
  all_types_NONE = 0,
  all_types_String = 1,
  all_types_Int = 2,
  all_types_Short = 3,
  all_types_Double = 4,
  all_types_Bool = 5,
  all_types_Container = 6,
  all_types_Tuple = 7,
  all_types_List = 8,
  all_types_Dict = 9,
  all_types_MIN = all_types_NONE,
  all_types_MAX = all_types_Dict
};

inline const all_types (&EnumValuesall_types())[10] {
  static const all_types values[] = {
    all_types_NONE,
    all_types_String,
    all_types_Int,
    all_types_Short,
    all_types_Double,
    all_types_Bool,
    all_types_Container,
    all_types_Tuple,
    all_types_List,
    all_types_Dict
  };
  return values;
}

inline const char * const *EnumNamesall_types() {
  static const char * const names[] = {
    "NONE",
    "String",
    "Int",
    "Short",
    "Double",
    "Bool",
    "Container",
    "Tuple",
    "List",
    "Dict",
    nullptr
  };
  return names;
}

inline const char *EnumNameall_types(all_types e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesall_types()[index];
}

template<typename T> struct all_typesTraits {
  static const all_types enum_value = all_types_NONE;
};

template<> struct all_typesTraits<String> {
  static const all_types enum_value = all_types_String;
};

template<> struct all_typesTraits<Int> {
  static const all_types enum_value = all_types_Int;
};

template<> struct all_typesTraits<Short> {
  static const all_types enum_value = all_types_Short;
};

template<> struct all_typesTraits<Double> {
  static const all_types enum_value = all_types_Double;
};

template<> struct all_typesTraits<Bool> {
  static const all_types enum_value = all_types_Bool;
};

template<> struct all_typesTraits<Container> {
  static const all_types enum_value = all_types_Container;
};

template<> struct all_typesTraits<Tuple> {
  static const all_types enum_value = all_types_Tuple;
};

template<> struct all_typesTraits<List> {
  static const all_types enum_value = all_types_List;
};

template<> struct all_typesTraits<Dict> {
  static const all_types enum_value = all_types_Dict;
};

bool Verifyall_types(flatbuffers::Verifier &verifier, const void *obj, all_types type);
bool Verifyall_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringBuilder &operator=(const StringBuilder &);
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return sweetPy::serialize::CreateString(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct Short FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShortBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Short::VT_VALUE, value, 0);
  }
  explicit ShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortBuilder &operator=(const ShortBuilder &);
  flatbuffers::Offset<Short> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Short>(end);
    return o;
  }
};

inline flatbuffers::Offset<Short> CreateShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  ShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleBuilder &operator=(const DoubleBuilder &);
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolBuilder &operator=(const BoolBuilder &);
  flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ContainerParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PARAM_TYPE = 4,
    VT_PARAM = 6
  };
  all_types param_type() const {
    return static_cast<all_types>(GetField<uint8_t>(VT_PARAM_TYPE, 0));
  }
  const void *param() const {
    return GetPointer<const void *>(VT_PARAM);
  }
  template<typename T> const T *param_as() const;
  const String *param_as_String() const {
    return param_type() == all_types_String ? static_cast<const String *>(param()) : nullptr;
  }
  const Int *param_as_Int() const {
    return param_type() == all_types_Int ? static_cast<const Int *>(param()) : nullptr;
  }
  const Short *param_as_Short() const {
    return param_type() == all_types_Short ? static_cast<const Short *>(param()) : nullptr;
  }
  const Double *param_as_Double() const {
    return param_type() == all_types_Double ? static_cast<const Double *>(param()) : nullptr;
  }
  const Bool *param_as_Bool() const {
    return param_type() == all_types_Bool ? static_cast<const Bool *>(param()) : nullptr;
  }
  const Container *param_as_Container() const {
    return param_type() == all_types_Container ? static_cast<const Container *>(param()) : nullptr;
  }
  const Tuple *param_as_Tuple() const {
    return param_type() == all_types_Tuple ? static_cast<const Tuple *>(param()) : nullptr;
  }
  const List *param_as_List() const {
    return param_type() == all_types_List ? static_cast<const List *>(param()) : nullptr;
  }
  const Dict *param_as_Dict() const {
    return param_type() == all_types_Dict ? static_cast<const Dict *>(param()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARAM_TYPE) &&
           VerifyOffset(verifier, VT_PARAM) &&
           Verifyall_types(verifier, param(), param_type()) &&
           verifier.EndTable();
  }
};

template<> inline const String *ContainerParam::param_as<String>() const {
  return param_as_String();
}

template<> inline const Int *ContainerParam::param_as<Int>() const {
  return param_as_Int();
}

template<> inline const Short *ContainerParam::param_as<Short>() const {
  return param_as_Short();
}

template<> inline const Double *ContainerParam::param_as<Double>() const {
  return param_as_Double();
}

template<> inline const Bool *ContainerParam::param_as<Bool>() const {
  return param_as_Bool();
}

template<> inline const Container *ContainerParam::param_as<Container>() const {
  return param_as_Container();
}

template<> inline const Tuple *ContainerParam::param_as<Tuple>() const {
  return param_as_Tuple();
}

template<> inline const List *ContainerParam::param_as<List>() const {
  return param_as_List();
}

template<> inline const Dict *ContainerParam::param_as<Dict>() const {
  return param_as_Dict();
}

struct ContainerParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_param_type(all_types param_type) {
    fbb_.AddElement<uint8_t>(ContainerParam::VT_PARAM_TYPE, static_cast<uint8_t>(param_type), 0);
  }
  void add_param(flatbuffers::Offset<void> param) {
    fbb_.AddOffset(ContainerParam::VT_PARAM, param);
  }
  explicit ContainerParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerParamBuilder &operator=(const ContainerParamBuilder &);
  flatbuffers::Offset<ContainerParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerParam> CreateContainerParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    all_types param_type = all_types_NONE,
    flatbuffers::Offset<void> param = 0) {
  ContainerParamBuilder builder_(_fbb);
  builder_.add_param(param);
  builder_.add_param_type(param_type);
  return builder_.Finish();
}

struct Container FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PARAMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ContainerParam>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ContainerParam>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct ContainerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContainerParam>>> params) {
    fbb_.AddOffset(Container::VT_PARAMS, params);
  }
  explicit ContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerBuilder &operator=(const ContainerBuilder &);
  flatbuffers::Offset<Container> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Container>(end);
    return o;
  }
};

inline flatbuffers::Offset<Container> CreateContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ContainerParam>>> params = 0) {
  ContainerBuilder builder_(_fbb);
  builder_.add_params(params);
  return builder_.Finish();
}

inline flatbuffers::Offset<Container> CreateContainerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ContainerParam>> *params = nullptr) {
  return sweetPy::serialize::CreateContainer(
      _fbb,
      params ? _fbb.CreateVector<flatbuffers::Offset<ContainerParam>>(*params) : 0);
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const Container *value() const {
    return GetPointer<const Container *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<Container> value) {
    fbb_.AddOffset(Tuple::VT_VALUE, value);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleBuilder &operator=(const TupleBuilder &);
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Container> value = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct List FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const Container *value() const {
    return GetPointer<const Container *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct ListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<Container> value) {
    fbb_.AddOffset(List::VT_VALUE, value);
  }
  explicit ListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListBuilder &operator=(const ListBuilder &);
  flatbuffers::Offset<List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<List>(end);
    return o;
  }
};

inline flatbuffers::Offset<List> CreateList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Container> value = 0) {
  ListBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DictParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY_TYPE = 4,
    VT_KEY = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  integral_types key_type() const {
    return static_cast<integral_types>(GetField<uint8_t>(VT_KEY_TYPE, 0));
  }
  const void *key() const {
    return GetPointer<const void *>(VT_KEY);
  }
  template<typename T> const T *key_as() const;
  const String *key_as_String() const {
    return key_type() == integral_types_String ? static_cast<const String *>(key()) : nullptr;
  }
  const Int *key_as_Int() const {
    return key_type() == integral_types_Int ? static_cast<const Int *>(key()) : nullptr;
  }
  const Short *key_as_Short() const {
    return key_type() == integral_types_Short ? static_cast<const Short *>(key()) : nullptr;
  }
  const Double *key_as_Double() const {
    return key_type() == integral_types_Double ? static_cast<const Double *>(key()) : nullptr;
  }
  const Bool *key_as_Bool() const {
    return key_type() == integral_types_Bool ? static_cast<const Bool *>(key()) : nullptr;
  }
  all_types value_type() const {
    return static_cast<all_types>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const String *value_as_String() const {
    return value_type() == all_types_String ? static_cast<const String *>(value()) : nullptr;
  }
  const Int *value_as_Int() const {
    return value_type() == all_types_Int ? static_cast<const Int *>(value()) : nullptr;
  }
  const Short *value_as_Short() const {
    return value_type() == all_types_Short ? static_cast<const Short *>(value()) : nullptr;
  }
  const Double *value_as_Double() const {
    return value_type() == all_types_Double ? static_cast<const Double *>(value()) : nullptr;
  }
  const Bool *value_as_Bool() const {
    return value_type() == all_types_Bool ? static_cast<const Bool *>(value()) : nullptr;
  }
  const Container *value_as_Container() const {
    return value_type() == all_types_Container ? static_cast<const Container *>(value()) : nullptr;
  }
  const Tuple *value_as_Tuple() const {
    return value_type() == all_types_Tuple ? static_cast<const Tuple *>(value()) : nullptr;
  }
  const List *value_as_List() const {
    return value_type() == all_types_List ? static_cast<const List *>(value()) : nullptr;
  }
  const Dict *value_as_Dict() const {
    return value_type() == all_types_Dict ? static_cast<const Dict *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY_TYPE) &&
           VerifyOffset(verifier, VT_KEY) &&
           Verifyintegral_types(verifier, key(), key_type()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           Verifyall_types(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const String *DictParam::key_as<String>() const {
  return key_as_String();
}

template<> inline const Int *DictParam::key_as<Int>() const {
  return key_as_Int();
}

template<> inline const Short *DictParam::key_as<Short>() const {
  return key_as_Short();
}

template<> inline const Double *DictParam::key_as<Double>() const {
  return key_as_Double();
}

template<> inline const Bool *DictParam::key_as<Bool>() const {
  return key_as_Bool();
}

template<> inline const String *DictParam::value_as<String>() const {
  return value_as_String();
}

template<> inline const Int *DictParam::value_as<Int>() const {
  return value_as_Int();
}

template<> inline const Short *DictParam::value_as<Short>() const {
  return value_as_Short();
}

template<> inline const Double *DictParam::value_as<Double>() const {
  return value_as_Double();
}

template<> inline const Bool *DictParam::value_as<Bool>() const {
  return value_as_Bool();
}

template<> inline const Container *DictParam::value_as<Container>() const {
  return value_as_Container();
}

template<> inline const Tuple *DictParam::value_as<Tuple>() const {
  return value_as_Tuple();
}

template<> inline const List *DictParam::value_as<List>() const {
  return value_as_List();
}

template<> inline const Dict *DictParam::value_as<Dict>() const {
  return value_as_Dict();
}

struct DictParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_type(integral_types key_type) {
    fbb_.AddElement<uint8_t>(DictParam::VT_KEY_TYPE, static_cast<uint8_t>(key_type), 0);
  }
  void add_key(flatbuffers::Offset<void> key) {
    fbb_.AddOffset(DictParam::VT_KEY, key);
  }
  void add_value_type(all_types value_type) {
    fbb_.AddElement<uint8_t>(DictParam::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(DictParam::VT_VALUE, value);
  }
  explicit DictParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DictParamBuilder &operator=(const DictParamBuilder &);
  flatbuffers::Offset<DictParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DictParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DictParam> CreateDictParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    integral_types key_type = integral_types_NONE,
    flatbuffers::Offset<void> key = 0,
    all_types value_type = all_types_NONE,
    flatbuffers::Offset<void> value = 0) {
  DictParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  return builder_.Finish();
}

struct Dict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PARAMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DictParam>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DictParam>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct DictBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DictParam>>> params) {
    fbb_.AddOffset(Dict::VT_PARAMS, params);
  }
  explicit DictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DictBuilder &operator=(const DictBuilder &);
  flatbuffers::Offset<Dict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dict>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dict> CreateDict(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DictParam>>> params = 0) {
  DictBuilder builder_(_fbb);
  builder_.add_params(params);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dict> CreateDictDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DictParam>> *params = nullptr) {
  return sweetPy::serialize::CreateDict(
      _fbb,
      params ? _fbb.CreateVector<flatbuffers::Offset<DictParam>>(*params) : 0);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  all_types object_type() const {
    return static_cast<all_types>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const String *object_as_String() const {
    return object_type() == all_types_String ? static_cast<const String *>(object()) : nullptr;
  }
  const Int *object_as_Int() const {
    return object_type() == all_types_Int ? static_cast<const Int *>(object()) : nullptr;
  }
  const Short *object_as_Short() const {
    return object_type() == all_types_Short ? static_cast<const Short *>(object()) : nullptr;
  }
  const Double *object_as_Double() const {
    return object_type() == all_types_Double ? static_cast<const Double *>(object()) : nullptr;
  }
  const Bool *object_as_Bool() const {
    return object_type() == all_types_Bool ? static_cast<const Bool *>(object()) : nullptr;
  }
  const Container *object_as_Container() const {
    return object_type() == all_types_Container ? static_cast<const Container *>(object()) : nullptr;
  }
  const Tuple *object_as_Tuple() const {
    return object_type() == all_types_Tuple ? static_cast<const Tuple *>(object()) : nullptr;
  }
  const List *object_as_List() const {
    return object_type() == all_types_List ? static_cast<const List *>(object()) : nullptr;
  }
  const Dict *object_as_Dict() const {
    return object_type() == all_types_Dict ? static_cast<const Dict *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           Verifyall_types(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const String *Object::object_as<String>() const {
  return object_as_String();
}

template<> inline const Int *Object::object_as<Int>() const {
  return object_as_Int();
}

template<> inline const Short *Object::object_as<Short>() const {
  return object_as_Short();
}

template<> inline const Double *Object::object_as<Double>() const {
  return object_as_Double();
}

template<> inline const Bool *Object::object_as<Bool>() const {
  return object_as_Bool();
}

template<> inline const Container *Object::object_as<Container>() const {
  return object_as_Container();
}

template<> inline const Tuple *Object::object_as<Tuple>() const {
  return object_as_Tuple();
}

template<> inline const List *Object::object_as<List>() const {
  return object_as_List();
}

template<> inline const Dict *Object::object_as<Dict>() const {
  return object_as_Dict();
}

struct ObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(all_types object_type) {
    fbb_.AddElement<uint8_t>(Object::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Object::VT_OBJECT, object);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    all_types object_type = all_types_NONE,
    flatbuffers::Offset<void> object = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Objects FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Object>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct ObjectsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects) {
    fbb_.AddOffset(Objects::VT_OBJECTS, objects);
  }
  explicit ObjectsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectsBuilder &operator=(const ObjectsBuilder &);
  flatbuffers::Offset<Objects> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Objects>(end);
    return o;
  }
};

inline flatbuffers::Offset<Objects> CreateObjects(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects = 0) {
  ObjectsBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<Objects> CreateObjectsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Object>> *objects = nullptr) {
  return sweetPy::serialize::CreateObjects(
      _fbb,
      objects ? _fbb.CreateVector<flatbuffers::Offset<Object>>(*objects) : 0);
}

inline bool Verifyintegral_types(flatbuffers::Verifier &verifier, const void *obj, integral_types type) {
  switch (type) {
    case integral_types_NONE: {
      return true;
    }
    case integral_types_String: {
      auto ptr = reinterpret_cast<const String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types_Int: {
      auto ptr = reinterpret_cast<const Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types_Short: {
      auto ptr = reinterpret_cast<const Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types_Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case integral_types_Bool: {
      auto ptr = reinterpret_cast<const Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool Verifyintegral_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifyintegral_types(
        verifier,  values->Get(i), types->GetEnum<integral_types>(i))) {
      return false;
    }
  }
  return true;
}

inline bool Verifyall_types(flatbuffers::Verifier &verifier, const void *obj, all_types type) {
  switch (type) {
    case all_types_NONE: {
      return true;
    }
    case all_types_String: {
      auto ptr = reinterpret_cast<const String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Int: {
      auto ptr = reinterpret_cast<const Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Short: {
      auto ptr = reinterpret_cast<const Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Bool: {
      auto ptr = reinterpret_cast<const Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Container: {
      auto ptr = reinterpret_cast<const Container *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Tuple: {
      auto ptr = reinterpret_cast<const Tuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_List: {
      auto ptr = reinterpret_cast<const List *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case all_types_Dict: {
      auto ptr = reinterpret_cast<const Dict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool Verifyall_typesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifyall_types(
        verifier,  values->Get(i), types->GetEnum<all_types>(i))) {
      return false;
    }
  }
  return true;
}

inline const sweetPy::serialize::Objects *GetObjects(const void *buf) {
  return flatbuffers::GetRoot<sweetPy::serialize::Objects>(buf);
}

inline const sweetPy::serialize::Objects *GetSizePrefixedObjects(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<sweetPy::serialize::Objects>(buf);
}

inline bool VerifyObjectsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sweetPy::serialize::Objects>(nullptr);
}

inline bool VerifySizePrefixedObjectsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sweetPy::serialize::Objects>(nullptr);
}

inline void FinishObjectsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sweetPy::serialize::Objects> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedObjectsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sweetPy::serialize::Objects> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace serialize
}  // namespace sweetPy

#endif  // FLATBUFFERS_GENERATED_TYPES_SWEETPY_SERIALIZE_H_
